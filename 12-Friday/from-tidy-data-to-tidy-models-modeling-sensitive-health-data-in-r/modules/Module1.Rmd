---
title: "tidyr and dplyr"
author: "Brooke Wolford"
date: "2025-12-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### License
This work is licensed under a Creative Commons Attribution 4.0 International License (CC BY 4.0). To view a copy of this license, visit: https://creativecommons.org/licenses/by/4.0/

This lesson is based on content from Software Carpentry
* https://swcarpentry.github.io/r-novice-inflammation/01-starting-with-data.html
* https://datacarpentry.github.io/genomics-r-intro/05-dplyr.html
* https://datacarpentry.github.io/r-socialsci/03-dplyr.html
* https://datacarpentry.github.io/r-socialsci/04-tidyr.html
* https://mqwilber.github.io/2015-04-17-ucsb/lessons/intro_R_lessons/R_data_plotting_analysis.html

 ChatGPT was used in the creation of examples and explanations.

### Objectives

Learners will be able to:
  * Load packages they have installed
  * Use the dplyr package to manipulate dataframes.
  * Use select() to choose variables from a dataframe.
  * Use filter() to choose data based on values.
  * Use group_by() and summarize() to work with subsets of data.
  * Use mutate() to create new variables.

# tidyr and dplyr

## Part 1: Introduction

### R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

A script ends in `.R` and a notebook ends in `.Rmd`

### Variables

Once a variable is created, we can use the variable name to refer to the value it was assigned. The variable name now acts as a tag. To see the value of a variable, we can print it by:
  1) typing the name of the variable and hitting return in the Console
  2) if your cursor is on a line in the editor window, you can use control-enter (PC) or command-return (Mac)
  3) press the Run button above
  4) press the green play button in the RMarkdown code chunk
In general, R will print to the console any object returned by a function or operation unless we assign it to a variable.

```{r}

#we use an arrow to assign a value to a variable
x<-5
class(x)

```

It is important that we name variables in a way that other users and our future selves will understand. Today, most R programmers 1) start variable names with lower case letters, 2) separate words in variable names with underscores, and 3) use only lowercase letters, underscores, and numbers in variable names. The [Tidyverse Style Guide](https://style.tidyverse.org/syntax.html) includes a section on this.

It's also important to use the `#` hash symbol to create comments for other users and our future selves.


### Packages and functions

Packages are collections of R functions, data, and compiled code in a well-defined format, created to add specific functionality. You can do a lot with base R, but there are 10,000+ user contributed packages on CRAN. The directories in R where the packages are stored are called the libraries.

In the R Console or when using R in Terminal, you can use the function `install.packages` to install a package. You can also use RStudio point-and-click functionality under the Packages tab. 

```{r}

#now we call the package we installed
library(dplyr)
library(tidyr)
library(readr)

#you could call all of these within the tidyverse, but it takes a long time to load
#library(tidyverse)

#if you haven't already installed these packages in the setup, you will need to do so
#install.packages("dplyr")

#what libraries and packages are loaded in the environment?
sessionInfo()

```

## Part 2: readr to read in data

We are going to use example data from Software Carpentry. I have already downloaded it and included it in the directory where this code is. If the directory with this code is showing in the Files pane in the bottom right, you can click on the More and select "Copy Folder Path to Clipboard." Paste that path below where it says "PASTE HERE". Be sure to keep the quotations and remove the hashtag.

```{r}

#path<-"PASTE HERE"
file<-"/sample.csv"
path<-paste0(path,file)

```

Now, let's read our data into R. There are several options for reading csv files:

- Base R has the function `read.csv()` which creates a basic data frame.
- I like to use the `data.table` package which has a function `fread()` and can be memory efficient for reading larger datasets. This creates a data.table object which has its own grammar for manipulating.
- The tidyverse has the `readr` package with the function `read_csv()`. This creates a tibble, a special type of data frame. 


```{r}

#let's inspect the function details
?read_csv

#we pass 2 arguments, the path where the file is, and information about if the file has column names
#we assign the data frame information to the variable "dat"
dat<-read_csv(file=path,col_names=TRUE)

	#for local access from Windows computers (given that the working directory is set to "../BioData-Training-School-2025/Day1_IntroR") 
		#NB: Cannot use file paths with the read_csv command on Windows, so working directory needs to be set beforehand
	#dat<-read_csv(file, col_names=TRUE)

#let's look at the first few rows 
dat %>% glimpse()

#what class is the object dat?
class(dat)

```

Each row holds the observations for just one patient. Each column holds values for several variables such as gender, blood pressure, and age.

For every column in the data frame, the function `summary` calculates: the minimum value, the first quartile, the median, the mean, the third quartile and the max value, giving helpful details about the sample distribution.
Like many programming languages, we can use indices to specify a certain row and column. The first value in brackets is row, and the second is column. R starts indices at 1, but some other languages use 0, so be mindful of this.

## Part 3: dplyr

Common dplyr verbs: `filter`, `select`, `mutate`, `summarize`, `group_by`
Check out the [dplyr cheatsheet](https://rstudio.github.io/cheatsheets/data-transformation.pdf)

Note: The packages in the tidyverse, namely dplyr, tidyr and ggplot2 accept both the British (e.g. summarise) and American (e.g. summarize) spelling variants of different function and option names.

### `filter()` and `select()`

`filter()` allows you to keep rows based on conditions using logical tests such as `==` or `%in%` or `>`. 

`select()` allows you to choose or reorder columns.

Note the order of the parameters, the name of the data frame first, and the additional details for filtering/selecting after.

```{r}

#in dplyr we can select the columns by name. Let's select only the Age column.
select(dat,Age)

#we can also filter based on a condition
filter(dat,BloodPressure>130)

```

### Pipes

The pipe is one of the core ideas in the tidyverse. It helps you write code that reads like a sequence of steps, making your analysis easier to understand and debug. The pipe takes the output of one function and passes it as the first argument to the next function. Think of it as saying: “and then…”

There are two Pipes in R: 
1) %>% (called magrittr pipe; made available via the magrittr package, installed automatically with dplyr)
2) |> (called native R pipe and it comes preinstalled with R v4.1.0 onwards). 
Both the pipes are, by and large, function similarly with a few differences.

```{r}

#another way to do this is with the pipe
dat %>% select(Age)

# we can use filter to filter observations for individuals with high blood pressure, this time let's save it into a new data frame
high <- dat %>% filter(BloodPressure>130)
high

```

What if we want to select and filter at the same time?

With intermediate steps, you create a temporary dataframe and use that as input to the next function.
You can also use nested functions (one function inside of another). R will evaluate the expression from the inside out.

In tidyverse, pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset. 

```{r}

#combining filter and select with a pipe
high_control_males<- dat %>% filter(Gender=="M"|Gender=="m")  %>% 
  filter(BloodPressure>130 & Group=="Control")

high_control_males

```




```{r}
#you can see we went from 100 to 30 observations when we used filter()
nrow(dat)
nrow(high)

# We can also specify multiple conditions within the filter() function.

#high blood pressure and the control group

# To form “and” statements within dplyr, we can pass our desired conditions as arguments in the filter() function, separated by commas:
high_control<-dat %>% filter(BloodPressure>130,Group=="Control")

# or we can use the ampersand "&" operator
high_control<-dat %>% filter(BloodPressure>130 & Group=="Control")

#how can we check that both of these filtered data frames are the same size?

# Have you noticed that the Gender column uses two conventions for male/female (lower case and upper case)?
table(dat$Gender)

# To filter for the male participants, we will need to accomodate both conventions

# For an “or” statement, observations must meet at least one of the specified conditions. To form “or” statements we use the logical operator for “or,” which is the vertical bar (|):

males <- dat %>% filter(Gender=="M"|Gender=="m")
table(males$Gender)

```


### `mutate()`

Frequently you’ll want to create new columns based on the values in existing columns, and for this you can use `mutate()`.

```{r}

#Let's fix the mismatched upper and lower case
dat %>% mutate(Gender_v2=toupper(Gender))

# Is the new column there?
names(dat)

# We have to save this back to the "dat" object so the new column will be represented in future versions of the tibble
dat <- dat %>% mutate(Gender_v2=toupper(Gender))
table(dat$Gender_v2)

```

### join

### `group_by()` and `summarize()`

Many data analysis tasks can be approached using the split-apply-combine paradigm: split the data into groups, apply some analysis to each group, and then combine the results. dplyr makes this very easy through the use of the `group_by()` function. `group_by()` is often used together with `summarize()`, which collapses each group into a single-row summary of that group.

```{r}

# What is the median blood pressure per treatment group?
dat %>%
  group_by(Group) %>%
  summarize(medianBP_group=median(BloodPressure))

# Can we also stratify by sex?
dat %>%
  group_by(Group,Gender_v2) %>%
  summarize(medianBP_group=median(BloodPressure))

```

### `count()`

```{r}

#how many of each treatment group are there?
dat %>% count(Group)

#let's sort by size
dat %>% count(Group,sort=TRUE)

```

## Part 4: tidyr

We use `tidyr` for structuring and reshaping data.

1. pivot_longer()

Turn wide data into long format.
	•	Good for repeated measures, questionnaires, time series.
	•	Key arguments: cols, names_to, values_to.

✔️ 2. pivot_wider()

Turn long data into wide format.
	•	Good for spreading categories across columns.
	•	Key arguments: names_from, values_from.

✔️ 3. separate()

Split one column into multiple based on a delimiter.
Useful for filenames, IDs, combined labels.

✔️ 4. unite()

Combine multiple columns into one (inverse of separate()).

✔️ 5. fill()

Fill down/up missing values within groups.

✔️ 6. drop_na() and replace_na()

Remove or replace NAs.

✔️ 7. nest() and unnest()

List-columns for modeling or per-group operations.
Useful when preparing data for purrr or per-group models.

### long and wide data

A lot of data you will encounter is in a long format:
1) each column is a variable
2) each row is an observation
3) each value has its own cell
Long format is more machine readable and is closer to the formatting of databases.

Alternatively, in a “wide” data format we see modifications to rule 1, where each column no longer represents a single variable. Instead, columns can represent different levels/values of a variable. 

The columns Aneurisms_q1-Aneurisms_q4 are total number of aneurysms for both eyes in four different quadrants of the eye. We can think of this part of the data frame as being rather wide. If we wanted it to be longer, we would have just 2 columns, one being the quadrant number and one being the number of aneurysms in the quadrant. 

Two key functions in `tidyr` are `pivot_longer()` and `pivot_wider()`. [tidyr cheatsheet](https://rstudio.github.io/cheatsheets/tidyr.pdf)

`pivot_longer()` takes four principal arguments:

1) the data
2) cols are the names of the columns we use to fill the a new values variable (or to drop).
3) the names_to column variable we wish to create from the cols provided.
4) the values_to column variable we wish to create and fill with values associated with the cols provided.

```{r}

#create new dataset called long
long<-dat %>% pivot_longer(cols=Aneurisms_q1:Aneurisms_q4,
                     names_to="Quadrant",
                     values_to="AneurismCount")
long

# what do you observe about the new data frame?

# now we can use group_by to summarize by quadrant, this would have been difficult in the previous format
long %>% group_by(Quadrant) %>% 
  summarize(median=median(AneurismCount))

```

We can think of the Group and BloodPressure columns of the dataset as being a long version of something that could be represented with a wide format. Let's test `pivot_wider` here.

`pivot_wider()` takes three principal arguments:

1) the data
2) the names_from column variable whose values will become new column names.
3) the values_from column variable whose values will fill the new column variables.

Further arguments include values_fill which, if set, fills in missing values with the value provided.

```{r}

#use pivot wider
dat %>% pivot_wider(names_from=Group,
            values_from = BloodPressure)

# You see we have NA in the cells that are missing. This probably isn't a good data format for this dataset, but it may come in handy in other scenarios.

```

## Part 5: Challenge

Task: Given a simple data frame of patients with ID, sex, age, and cholesterol values in two visits, write code to:
	1.	Filter patients over 45 years and save to a new dataset called sub, how many are there?
	2.  Select ID, Sex, and Cholesterol columns to a new dataset called sub2.
	3.	Using sub2, create a new variable that is 1 if the patient has high cholesterol (over 200), and 0 otherwise. Save this to a datset called high.
	4.	Using sub2, summarize average cholesterol by sex

```{r}

df <- data.frame(
  ID = 1:8,
  Age = c(34, 60, 45, 50, 29, 80, 55, 65),
  SBP = c(120, 140, 135, 150, 110, 140, 120, 125 ),
  cholesterol = c(200,220, 190, 195, 180, 240, 230, 235),
  sex = c("Male","Male","Female","Male","Female","Female","Male","Male")
)

# Filter patients over 45 and save to a new dataset named sub


# How many patients are over 45?


# In the original dataset, select the ID, sex, and cholesterol column for a new dataset


# Create a new variable (indicator variable) showing whether cholesterol is above 200


# Summarize average cholesterol by sex

